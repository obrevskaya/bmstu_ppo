package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/ovv20u676/ppo/src/internal/interfaces.IWineRepository -o ../mocks/i_wine_repository_mock_test.go -n IWineRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/ovv20u676/ppo/src/backend/internal/logic/models"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// IWineRepositoryMock implements interfaces.IWineRepository
type IWineRepositoryMock struct {
	t minimock.Tester

	funcDelete          func(ctx context.Context, ID uuid.UUID) (err error)
	inspectFuncDelete   func(ctx context.Context, ID uuid.UUID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mIWineRepositoryMockDelete

	funcGetWine          func(ctx context.Context, ID uuid.UUID) (wp1 *models.Wine, err error)
	inspectFuncGetWine   func(ctx context.Context, ID uuid.UUID)
	afterGetWineCounter  uint64
	beforeGetWineCounter uint64
	GetWineMock          mIWineRepositoryMockGetWine

	funcGetWines          func(ctx context.Context, limit int, skip int) (wpa1 []*models.Wine, err error)
	inspectFuncGetWines   func(ctx context.Context, limit int, skip int)
	afterGetWinesCounter  uint64
	beforeGetWinesCounter uint64
	GetWinesMock          mIWineRepositoryMockGetWines

	funcInsert          func(ctx context.Context, wine *models.Wine) (err error)
	inspectFuncInsert   func(ctx context.Context, wine *models.Wine)
	afterInsertCounter  uint64
	beforeInsertCounter uint64
	InsertMock          mIWineRepositoryMockInsert

	funcReduceWines          func(ctx context.Context, id []*models.OrderElement) (err error)
	inspectFuncReduceWines   func(ctx context.Context, id []*models.OrderElement)
	afterReduceWinesCounter  uint64
	beforeReduceWinesCounter uint64
	ReduceWinesMock          mIWineRepositoryMockReduceWines

	funcUpdate          func(ctx context.Context, wine *models.Wine) (err error)
	inspectFuncUpdate   func(ctx context.Context, wine *models.Wine)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mIWineRepositoryMockUpdate
}

// NewIWineRepositoryMock returns a mock for interfaces.IWineRepository
func NewIWineRepositoryMock(t minimock.Tester) *IWineRepositoryMock {
	m := &IWineRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mIWineRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*IWineRepositoryMockDeleteParams{}

	m.GetWineMock = mIWineRepositoryMockGetWine{mock: m}
	m.GetWineMock.callArgs = []*IWineRepositoryMockGetWineParams{}

	m.GetWinesMock = mIWineRepositoryMockGetWines{mock: m}
	m.GetWinesMock.callArgs = []*IWineRepositoryMockGetWinesParams{}

	m.InsertMock = mIWineRepositoryMockInsert{mock: m}
	m.InsertMock.callArgs = []*IWineRepositoryMockInsertParams{}

	m.ReduceWinesMock = mIWineRepositoryMockReduceWines{mock: m}
	m.ReduceWinesMock.callArgs = []*IWineRepositoryMockReduceWinesParams{}

	m.UpdateMock = mIWineRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*IWineRepositoryMockUpdateParams{}

	return m
}

type mIWineRepositoryMockDelete struct {
	mock               *IWineRepositoryMock
	defaultExpectation *IWineRepositoryMockDeleteExpectation
	expectations       []*IWineRepositoryMockDeleteExpectation

	callArgs []*IWineRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// IWineRepositoryMockDeleteExpectation specifies expectation struct of the IWineRepository.Delete
type IWineRepositoryMockDeleteExpectation struct {
	mock    *IWineRepositoryMock
	params  *IWineRepositoryMockDeleteParams
	results *IWineRepositoryMockDeleteResults
	Counter uint64
}

// IWineRepositoryMockDeleteParams contains parameters of the IWineRepository.Delete
type IWineRepositoryMockDeleteParams struct {
	ctx context.Context
	ID  uuid.UUID
}

// IWineRepositoryMockDeleteResults contains results of the IWineRepository.Delete
type IWineRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for IWineRepository.Delete
func (mmDelete *mIWineRepositoryMockDelete) Expect(ctx context.Context, ID uuid.UUID) *mIWineRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IWineRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IWineRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &IWineRepositoryMockDeleteParams{ctx, ID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the IWineRepository.Delete
func (mmDelete *mIWineRepositoryMockDelete) Inspect(f func(ctx context.Context, ID uuid.UUID)) *mIWineRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for IWineRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by IWineRepository.Delete
func (mmDelete *mIWineRepositoryMockDelete) Return(err error) *IWineRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IWineRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &IWineRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &IWineRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the IWineRepository.Delete method
func (mmDelete *mIWineRepositoryMockDelete) Set(f func(ctx context.Context, ID uuid.UUID) (err error)) *IWineRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the IWineRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the IWineRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the IWineRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mIWineRepositoryMockDelete) When(ctx context.Context, ID uuid.UUID) *IWineRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("IWineRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &IWineRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &IWineRepositoryMockDeleteParams{ctx, ID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up IWineRepository.Delete return parameters for the expectation previously defined by the When method
func (e *IWineRepositoryMockDeleteExpectation) Then(err error) *IWineRepositoryMock {
	e.results = &IWineRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements interfaces.IWineRepository
func (mmDelete *IWineRepositoryMock) Delete(ctx context.Context, ID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, ID)
	}

	mm_params := &IWineRepositoryMockDeleteParams{ctx, ID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := IWineRepositoryMockDeleteParams{ctx, ID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("IWineRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the IWineRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, ID)
	}
	mmDelete.t.Fatalf("Unexpected call to IWineRepositoryMock.Delete. %v %v", ctx, ID)
	return
}

// DeleteAfterCounter returns a count of finished IWineRepositoryMock.Delete invocations
func (mmDelete *IWineRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of IWineRepositoryMock.Delete invocations
func (mmDelete *IWineRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to IWineRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mIWineRepositoryMockDelete) Calls() []*IWineRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*IWineRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *IWineRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *IWineRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IWineRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IWineRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to IWineRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to IWineRepositoryMock.Delete")
	}
}

type mIWineRepositoryMockGetWine struct {
	mock               *IWineRepositoryMock
	defaultExpectation *IWineRepositoryMockGetWineExpectation
	expectations       []*IWineRepositoryMockGetWineExpectation

	callArgs []*IWineRepositoryMockGetWineParams
	mutex    sync.RWMutex
}

// IWineRepositoryMockGetWineExpectation specifies expectation struct of the IWineRepository.GetWine
type IWineRepositoryMockGetWineExpectation struct {
	mock    *IWineRepositoryMock
	params  *IWineRepositoryMockGetWineParams
	results *IWineRepositoryMockGetWineResults
	Counter uint64
}

// IWineRepositoryMockGetWineParams contains parameters of the IWineRepository.GetWine
type IWineRepositoryMockGetWineParams struct {
	ctx context.Context
	ID  uuid.UUID
}

// IWineRepositoryMockGetWineResults contains results of the IWineRepository.GetWine
type IWineRepositoryMockGetWineResults struct {
	wp1 *models.Wine
	err error
}

// Expect sets up expected params for IWineRepository.GetWine
func (mmGetWine *mIWineRepositoryMockGetWine) Expect(ctx context.Context, ID uuid.UUID) *mIWineRepositoryMockGetWine {
	if mmGetWine.mock.funcGetWine != nil {
		mmGetWine.mock.t.Fatalf("IWineRepositoryMock.GetWine mock is already set by Set")
	}

	if mmGetWine.defaultExpectation == nil {
		mmGetWine.defaultExpectation = &IWineRepositoryMockGetWineExpectation{}
	}

	mmGetWine.defaultExpectation.params = &IWineRepositoryMockGetWineParams{ctx, ID}
	for _, e := range mmGetWine.expectations {
		if minimock.Equal(e.params, mmGetWine.defaultExpectation.params) {
			mmGetWine.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWine.defaultExpectation.params)
		}
	}

	return mmGetWine
}

// Inspect accepts an inspector function that has same arguments as the IWineRepository.GetWine
func (mmGetWine *mIWineRepositoryMockGetWine) Inspect(f func(ctx context.Context, ID uuid.UUID)) *mIWineRepositoryMockGetWine {
	if mmGetWine.mock.inspectFuncGetWine != nil {
		mmGetWine.mock.t.Fatalf("Inspect function is already set for IWineRepositoryMock.GetWine")
	}

	mmGetWine.mock.inspectFuncGetWine = f

	return mmGetWine
}

// Return sets up results that will be returned by IWineRepository.GetWine
func (mmGetWine *mIWineRepositoryMockGetWine) Return(wp1 *models.Wine, err error) *IWineRepositoryMock {
	if mmGetWine.mock.funcGetWine != nil {
		mmGetWine.mock.t.Fatalf("IWineRepositoryMock.GetWine mock is already set by Set")
	}

	if mmGetWine.defaultExpectation == nil {
		mmGetWine.defaultExpectation = &IWineRepositoryMockGetWineExpectation{mock: mmGetWine.mock}
	}
	mmGetWine.defaultExpectation.results = &IWineRepositoryMockGetWineResults{wp1, err}
	return mmGetWine.mock
}

// Set uses given function f to mock the IWineRepository.GetWine method
func (mmGetWine *mIWineRepositoryMockGetWine) Set(f func(ctx context.Context, ID uuid.UUID) (wp1 *models.Wine, err error)) *IWineRepositoryMock {
	if mmGetWine.defaultExpectation != nil {
		mmGetWine.mock.t.Fatalf("Default expectation is already set for the IWineRepository.GetWine method")
	}

	if len(mmGetWine.expectations) > 0 {
		mmGetWine.mock.t.Fatalf("Some expectations are already set for the IWineRepository.GetWine method")
	}

	mmGetWine.mock.funcGetWine = f
	return mmGetWine.mock
}

// When sets expectation for the IWineRepository.GetWine which will trigger the result defined by the following
// Then helper
func (mmGetWine *mIWineRepositoryMockGetWine) When(ctx context.Context, ID uuid.UUID) *IWineRepositoryMockGetWineExpectation {
	if mmGetWine.mock.funcGetWine != nil {
		mmGetWine.mock.t.Fatalf("IWineRepositoryMock.GetWine mock is already set by Set")
	}

	expectation := &IWineRepositoryMockGetWineExpectation{
		mock:   mmGetWine.mock,
		params: &IWineRepositoryMockGetWineParams{ctx, ID},
	}
	mmGetWine.expectations = append(mmGetWine.expectations, expectation)
	return expectation
}

// Then sets up IWineRepository.GetWine return parameters for the expectation previously defined by the When method
func (e *IWineRepositoryMockGetWineExpectation) Then(wp1 *models.Wine, err error) *IWineRepositoryMock {
	e.results = &IWineRepositoryMockGetWineResults{wp1, err}
	return e.mock
}

// GetWine implements interfaces.IWineRepository
func (mmGetWine *IWineRepositoryMock) GetWine(ctx context.Context, ID uuid.UUID) (wp1 *models.Wine, err error) {
	mm_atomic.AddUint64(&mmGetWine.beforeGetWineCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWine.afterGetWineCounter, 1)

	if mmGetWine.inspectFuncGetWine != nil {
		mmGetWine.inspectFuncGetWine(ctx, ID)
	}

	mm_params := &IWineRepositoryMockGetWineParams{ctx, ID}

	// Record call args
	mmGetWine.GetWineMock.mutex.Lock()
	mmGetWine.GetWineMock.callArgs = append(mmGetWine.GetWineMock.callArgs, mm_params)
	mmGetWine.GetWineMock.mutex.Unlock()

	for _, e := range mmGetWine.GetWineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wp1, e.results.err
		}
	}

	if mmGetWine.GetWineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWine.GetWineMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWine.GetWineMock.defaultExpectation.params
		mm_got := IWineRepositoryMockGetWineParams{ctx, ID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWine.t.Errorf("IWineRepositoryMock.GetWine got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWine.GetWineMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWine.t.Fatal("No results are set for the IWineRepositoryMock.GetWine")
		}
		return (*mm_results).wp1, (*mm_results).err
	}
	if mmGetWine.funcGetWine != nil {
		return mmGetWine.funcGetWine(ctx, ID)
	}
	mmGetWine.t.Fatalf("Unexpected call to IWineRepositoryMock.GetWine. %v %v", ctx, ID)
	return
}

// GetWineAfterCounter returns a count of finished IWineRepositoryMock.GetWine invocations
func (mmGetWine *IWineRepositoryMock) GetWineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWine.afterGetWineCounter)
}

// GetWineBeforeCounter returns a count of IWineRepositoryMock.GetWine invocations
func (mmGetWine *IWineRepositoryMock) GetWineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWine.beforeGetWineCounter)
}

// Calls returns a list of arguments used in each call to IWineRepositoryMock.GetWine.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWine *mIWineRepositoryMockGetWine) Calls() []*IWineRepositoryMockGetWineParams {
	mmGetWine.mutex.RLock()

	argCopy := make([]*IWineRepositoryMockGetWineParams, len(mmGetWine.callArgs))
	copy(argCopy, mmGetWine.callArgs)

	mmGetWine.mutex.RUnlock()

	return argCopy
}

// MinimockGetWineDone returns true if the count of the GetWine invocations corresponds
// the number of defined expectations
func (m *IWineRepositoryMock) MinimockGetWineDone() bool {
	for _, e := range m.GetWineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWine != nil && mm_atomic.LoadUint64(&m.afterGetWineCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWineInspect logs each unmet expectation
func (m *IWineRepositoryMock) MinimockGetWineInspect() {
	for _, e := range m.GetWineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IWineRepositoryMock.GetWine with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWineCounter) < 1 {
		if m.GetWineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IWineRepositoryMock.GetWine")
		} else {
			m.t.Errorf("Expected call to IWineRepositoryMock.GetWine with params: %#v", *m.GetWineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWine != nil && mm_atomic.LoadUint64(&m.afterGetWineCounter) < 1 {
		m.t.Error("Expected call to IWineRepositoryMock.GetWine")
	}
}

type mIWineRepositoryMockGetWines struct {
	mock               *IWineRepositoryMock
	defaultExpectation *IWineRepositoryMockGetWinesExpectation
	expectations       []*IWineRepositoryMockGetWinesExpectation

	callArgs []*IWineRepositoryMockGetWinesParams
	mutex    sync.RWMutex
}

// IWineRepositoryMockGetWinesExpectation specifies expectation struct of the IWineRepository.GetWines
type IWineRepositoryMockGetWinesExpectation struct {
	mock    *IWineRepositoryMock
	params  *IWineRepositoryMockGetWinesParams
	results *IWineRepositoryMockGetWinesResults
	Counter uint64
}

// IWineRepositoryMockGetWinesParams contains parameters of the IWineRepository.GetWines
type IWineRepositoryMockGetWinesParams struct {
	ctx   context.Context
	limit int
	skip  int
}

// IWineRepositoryMockGetWinesResults contains results of the IWineRepository.GetWines
type IWineRepositoryMockGetWinesResults struct {
	wpa1 []*models.Wine
	err  error
}

// Expect sets up expected params for IWineRepository.GetWines
func (mmGetWines *mIWineRepositoryMockGetWines) Expect(ctx context.Context, limit int, skip int) *mIWineRepositoryMockGetWines {
	if mmGetWines.mock.funcGetWines != nil {
		mmGetWines.mock.t.Fatalf("IWineRepositoryMock.GetWines mock is already set by Set")
	}

	if mmGetWines.defaultExpectation == nil {
		mmGetWines.defaultExpectation = &IWineRepositoryMockGetWinesExpectation{}
	}

	mmGetWines.defaultExpectation.params = &IWineRepositoryMockGetWinesParams{ctx, limit, skip}
	for _, e := range mmGetWines.expectations {
		if minimock.Equal(e.params, mmGetWines.defaultExpectation.params) {
			mmGetWines.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetWines.defaultExpectation.params)
		}
	}

	return mmGetWines
}

// Inspect accepts an inspector function that has same arguments as the IWineRepository.GetWines
func (mmGetWines *mIWineRepositoryMockGetWines) Inspect(f func(ctx context.Context, limit int, skip int)) *mIWineRepositoryMockGetWines {
	if mmGetWines.mock.inspectFuncGetWines != nil {
		mmGetWines.mock.t.Fatalf("Inspect function is already set for IWineRepositoryMock.GetWines")
	}

	mmGetWines.mock.inspectFuncGetWines = f

	return mmGetWines
}

// Return sets up results that will be returned by IWineRepository.GetWines
func (mmGetWines *mIWineRepositoryMockGetWines) Return(wpa1 []*models.Wine, err error) *IWineRepositoryMock {
	if mmGetWines.mock.funcGetWines != nil {
		mmGetWines.mock.t.Fatalf("IWineRepositoryMock.GetWines mock is already set by Set")
	}

	if mmGetWines.defaultExpectation == nil {
		mmGetWines.defaultExpectation = &IWineRepositoryMockGetWinesExpectation{mock: mmGetWines.mock}
	}
	mmGetWines.defaultExpectation.results = &IWineRepositoryMockGetWinesResults{wpa1, err}
	return mmGetWines.mock
}

// Set uses given function f to mock the IWineRepository.GetWines method
func (mmGetWines *mIWineRepositoryMockGetWines) Set(f func(ctx context.Context, limit int, skip int) (wpa1 []*models.Wine, err error)) *IWineRepositoryMock {
	if mmGetWines.defaultExpectation != nil {
		mmGetWines.mock.t.Fatalf("Default expectation is already set for the IWineRepository.GetWines method")
	}

	if len(mmGetWines.expectations) > 0 {
		mmGetWines.mock.t.Fatalf("Some expectations are already set for the IWineRepository.GetWines method")
	}

	mmGetWines.mock.funcGetWines = f
	return mmGetWines.mock
}

// When sets expectation for the IWineRepository.GetWines which will trigger the result defined by the following
// Then helper
func (mmGetWines *mIWineRepositoryMockGetWines) When(ctx context.Context, limit int, skip int) *IWineRepositoryMockGetWinesExpectation {
	if mmGetWines.mock.funcGetWines != nil {
		mmGetWines.mock.t.Fatalf("IWineRepositoryMock.GetWines mock is already set by Set")
	}

	expectation := &IWineRepositoryMockGetWinesExpectation{
		mock:   mmGetWines.mock,
		params: &IWineRepositoryMockGetWinesParams{ctx, limit, skip},
	}
	mmGetWines.expectations = append(mmGetWines.expectations, expectation)
	return expectation
}

// Then sets up IWineRepository.GetWines return parameters for the expectation previously defined by the When method
func (e *IWineRepositoryMockGetWinesExpectation) Then(wpa1 []*models.Wine, err error) *IWineRepositoryMock {
	e.results = &IWineRepositoryMockGetWinesResults{wpa1, err}
	return e.mock
}

// GetWines implements interfaces.IWineRepository
func (mmGetWines *IWineRepositoryMock) GetWines(ctx context.Context, limit int, skip int) (wpa1 []*models.Wine, err error) {
	mm_atomic.AddUint64(&mmGetWines.beforeGetWinesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWines.afterGetWinesCounter, 1)

	if mmGetWines.inspectFuncGetWines != nil {
		mmGetWines.inspectFuncGetWines(ctx, limit, skip)
	}

	mm_params := &IWineRepositoryMockGetWinesParams{ctx, limit, skip}

	// Record call args
	mmGetWines.GetWinesMock.mutex.Lock()
	mmGetWines.GetWinesMock.callArgs = append(mmGetWines.GetWinesMock.callArgs, mm_params)
	mmGetWines.GetWinesMock.mutex.Unlock()

	for _, e := range mmGetWines.GetWinesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.wpa1, e.results.err
		}
	}

	if mmGetWines.GetWinesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWines.GetWinesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetWines.GetWinesMock.defaultExpectation.params
		mm_got := IWineRepositoryMockGetWinesParams{ctx, limit, skip}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetWines.t.Errorf("IWineRepositoryMock.GetWines got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetWines.GetWinesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWines.t.Fatal("No results are set for the IWineRepositoryMock.GetWines")
		}
		return (*mm_results).wpa1, (*mm_results).err
	}
	if mmGetWines.funcGetWines != nil {
		return mmGetWines.funcGetWines(ctx, limit, skip)
	}
	mmGetWines.t.Fatalf("Unexpected call to IWineRepositoryMock.GetWines. %v %v %v", ctx, limit, skip)
	return
}

// GetWinesAfterCounter returns a count of finished IWineRepositoryMock.GetWines invocations
func (mmGetWines *IWineRepositoryMock) GetWinesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWines.afterGetWinesCounter)
}

// GetWinesBeforeCounter returns a count of IWineRepositoryMock.GetWines invocations
func (mmGetWines *IWineRepositoryMock) GetWinesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWines.beforeGetWinesCounter)
}

// Calls returns a list of arguments used in each call to IWineRepositoryMock.GetWines.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetWines *mIWineRepositoryMockGetWines) Calls() []*IWineRepositoryMockGetWinesParams {
	mmGetWines.mutex.RLock()

	argCopy := make([]*IWineRepositoryMockGetWinesParams, len(mmGetWines.callArgs))
	copy(argCopy, mmGetWines.callArgs)

	mmGetWines.mutex.RUnlock()

	return argCopy
}

// MinimockGetWinesDone returns true if the count of the GetWines invocations corresponds
// the number of defined expectations
func (m *IWineRepositoryMock) MinimockGetWinesDone() bool {
	for _, e := range m.GetWinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWinesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWinesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWines != nil && mm_atomic.LoadUint64(&m.afterGetWinesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetWinesInspect logs each unmet expectation
func (m *IWineRepositoryMock) MinimockGetWinesInspect() {
	for _, e := range m.GetWinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IWineRepositoryMock.GetWines with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetWinesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetWinesCounter) < 1 {
		if m.GetWinesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IWineRepositoryMock.GetWines")
		} else {
			m.t.Errorf("Expected call to IWineRepositoryMock.GetWines with params: %#v", *m.GetWinesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWines != nil && mm_atomic.LoadUint64(&m.afterGetWinesCounter) < 1 {
		m.t.Error("Expected call to IWineRepositoryMock.GetWines")
	}
}

type mIWineRepositoryMockInsert struct {
	mock               *IWineRepositoryMock
	defaultExpectation *IWineRepositoryMockInsertExpectation
	expectations       []*IWineRepositoryMockInsertExpectation

	callArgs []*IWineRepositoryMockInsertParams
	mutex    sync.RWMutex
}

// IWineRepositoryMockInsertExpectation specifies expectation struct of the IWineRepository.Insert
type IWineRepositoryMockInsertExpectation struct {
	mock    *IWineRepositoryMock
	params  *IWineRepositoryMockInsertParams
	results *IWineRepositoryMockInsertResults
	Counter uint64
}

// IWineRepositoryMockInsertParams contains parameters of the IWineRepository.Insert
type IWineRepositoryMockInsertParams struct {
	ctx  context.Context
	wine *models.Wine
}

// IWineRepositoryMockInsertResults contains results of the IWineRepository.Insert
type IWineRepositoryMockInsertResults struct {
	err error
}

// Expect sets up expected params for IWineRepository.Insert
func (mmInsert *mIWineRepositoryMockInsert) Expect(ctx context.Context, wine *models.Wine) *mIWineRepositoryMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("IWineRepositoryMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &IWineRepositoryMockInsertExpectation{}
	}

	mmInsert.defaultExpectation.params = &IWineRepositoryMockInsertParams{ctx, wine}
	for _, e := range mmInsert.expectations {
		if minimock.Equal(e.params, mmInsert.defaultExpectation.params) {
			mmInsert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsert.defaultExpectation.params)
		}
	}

	return mmInsert
}

// Inspect accepts an inspector function that has same arguments as the IWineRepository.Insert
func (mmInsert *mIWineRepositoryMockInsert) Inspect(f func(ctx context.Context, wine *models.Wine)) *mIWineRepositoryMockInsert {
	if mmInsert.mock.inspectFuncInsert != nil {
		mmInsert.mock.t.Fatalf("Inspect function is already set for IWineRepositoryMock.Insert")
	}

	mmInsert.mock.inspectFuncInsert = f

	return mmInsert
}

// Return sets up results that will be returned by IWineRepository.Insert
func (mmInsert *mIWineRepositoryMockInsert) Return(err error) *IWineRepositoryMock {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("IWineRepositoryMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &IWineRepositoryMockInsertExpectation{mock: mmInsert.mock}
	}
	mmInsert.defaultExpectation.results = &IWineRepositoryMockInsertResults{err}
	return mmInsert.mock
}

// Set uses given function f to mock the IWineRepository.Insert method
func (mmInsert *mIWineRepositoryMockInsert) Set(f func(ctx context.Context, wine *models.Wine) (err error)) *IWineRepositoryMock {
	if mmInsert.defaultExpectation != nil {
		mmInsert.mock.t.Fatalf("Default expectation is already set for the IWineRepository.Insert method")
	}

	if len(mmInsert.expectations) > 0 {
		mmInsert.mock.t.Fatalf("Some expectations are already set for the IWineRepository.Insert method")
	}

	mmInsert.mock.funcInsert = f
	return mmInsert.mock
}

// When sets expectation for the IWineRepository.Insert which will trigger the result defined by the following
// Then helper
func (mmInsert *mIWineRepositoryMockInsert) When(ctx context.Context, wine *models.Wine) *IWineRepositoryMockInsertExpectation {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("IWineRepositoryMock.Insert mock is already set by Set")
	}

	expectation := &IWineRepositoryMockInsertExpectation{
		mock:   mmInsert.mock,
		params: &IWineRepositoryMockInsertParams{ctx, wine},
	}
	mmInsert.expectations = append(mmInsert.expectations, expectation)
	return expectation
}

// Then sets up IWineRepository.Insert return parameters for the expectation previously defined by the When method
func (e *IWineRepositoryMockInsertExpectation) Then(err error) *IWineRepositoryMock {
	e.results = &IWineRepositoryMockInsertResults{err}
	return e.mock
}

// Insert implements interfaces.IWineRepository
func (mmInsert *IWineRepositoryMock) Insert(ctx context.Context, wine *models.Wine) (err error) {
	mm_atomic.AddUint64(&mmInsert.beforeInsertCounter, 1)
	defer mm_atomic.AddUint64(&mmInsert.afterInsertCounter, 1)

	if mmInsert.inspectFuncInsert != nil {
		mmInsert.inspectFuncInsert(ctx, wine)
	}

	mm_params := &IWineRepositoryMockInsertParams{ctx, wine}

	// Record call args
	mmInsert.InsertMock.mutex.Lock()
	mmInsert.InsertMock.callArgs = append(mmInsert.InsertMock.callArgs, mm_params)
	mmInsert.InsertMock.mutex.Unlock()

	for _, e := range mmInsert.InsertMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsert.InsertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsert.InsertMock.defaultExpectation.Counter, 1)
		mm_want := mmInsert.InsertMock.defaultExpectation.params
		mm_got := IWineRepositoryMockInsertParams{ctx, wine}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsert.t.Errorf("IWineRepositoryMock.Insert got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsert.InsertMock.defaultExpectation.results
		if mm_results == nil {
			mmInsert.t.Fatal("No results are set for the IWineRepositoryMock.Insert")
		}
		return (*mm_results).err
	}
	if mmInsert.funcInsert != nil {
		return mmInsert.funcInsert(ctx, wine)
	}
	mmInsert.t.Fatalf("Unexpected call to IWineRepositoryMock.Insert. %v %v", ctx, wine)
	return
}

// InsertAfterCounter returns a count of finished IWineRepositoryMock.Insert invocations
func (mmInsert *IWineRepositoryMock) InsertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.afterInsertCounter)
}

// InsertBeforeCounter returns a count of IWineRepositoryMock.Insert invocations
func (mmInsert *IWineRepositoryMock) InsertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.beforeInsertCounter)
}

// Calls returns a list of arguments used in each call to IWineRepositoryMock.Insert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsert *mIWineRepositoryMockInsert) Calls() []*IWineRepositoryMockInsertParams {
	mmInsert.mutex.RLock()

	argCopy := make([]*IWineRepositoryMockInsertParams, len(mmInsert.callArgs))
	copy(argCopy, mmInsert.callArgs)

	mmInsert.mutex.RUnlock()

	return argCopy
}

// MinimockInsertDone returns true if the count of the Insert invocations corresponds
// the number of defined expectations
func (m *IWineRepositoryMock) MinimockInsertDone() bool {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertInspect logs each unmet expectation
func (m *IWineRepositoryMock) MinimockInsertInspect() {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IWineRepositoryMock.Insert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		if m.InsertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IWineRepositoryMock.Insert")
		} else {
			m.t.Errorf("Expected call to IWineRepositoryMock.Insert with params: %#v", *m.InsertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		m.t.Error("Expected call to IWineRepositoryMock.Insert")
	}
}

type mIWineRepositoryMockReduceWines struct {
	mock               *IWineRepositoryMock
	defaultExpectation *IWineRepositoryMockReduceWinesExpectation
	expectations       []*IWineRepositoryMockReduceWinesExpectation

	callArgs []*IWineRepositoryMockReduceWinesParams
	mutex    sync.RWMutex
}

// IWineRepositoryMockReduceWinesExpectation specifies expectation struct of the IWineRepository.ReduceWines
type IWineRepositoryMockReduceWinesExpectation struct {
	mock    *IWineRepositoryMock
	params  *IWineRepositoryMockReduceWinesParams
	results *IWineRepositoryMockReduceWinesResults
	Counter uint64
}

// IWineRepositoryMockReduceWinesParams contains parameters of the IWineRepository.ReduceWines
type IWineRepositoryMockReduceWinesParams struct {
	ctx context.Context
	id  []*models.OrderElement
}

// IWineRepositoryMockReduceWinesResults contains results of the IWineRepository.ReduceWines
type IWineRepositoryMockReduceWinesResults struct {
	err error
}

// Expect sets up expected params for IWineRepository.ReduceWines
func (mmReduceWines *mIWineRepositoryMockReduceWines) Expect(ctx context.Context, id []*models.OrderElement) *mIWineRepositoryMockReduceWines {
	if mmReduceWines.mock.funcReduceWines != nil {
		mmReduceWines.mock.t.Fatalf("IWineRepositoryMock.ReduceWines mock is already set by Set")
	}

	if mmReduceWines.defaultExpectation == nil {
		mmReduceWines.defaultExpectation = &IWineRepositoryMockReduceWinesExpectation{}
	}

	mmReduceWines.defaultExpectation.params = &IWineRepositoryMockReduceWinesParams{ctx, id}
	for _, e := range mmReduceWines.expectations {
		if minimock.Equal(e.params, mmReduceWines.defaultExpectation.params) {
			mmReduceWines.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReduceWines.defaultExpectation.params)
		}
	}

	return mmReduceWines
}

// Inspect accepts an inspector function that has same arguments as the IWineRepository.ReduceWines
func (mmReduceWines *mIWineRepositoryMockReduceWines) Inspect(f func(ctx context.Context, id []*models.OrderElement)) *mIWineRepositoryMockReduceWines {
	if mmReduceWines.mock.inspectFuncReduceWines != nil {
		mmReduceWines.mock.t.Fatalf("Inspect function is already set for IWineRepositoryMock.ReduceWines")
	}

	mmReduceWines.mock.inspectFuncReduceWines = f

	return mmReduceWines
}

// Return sets up results that will be returned by IWineRepository.ReduceWines
func (mmReduceWines *mIWineRepositoryMockReduceWines) Return(err error) *IWineRepositoryMock {
	if mmReduceWines.mock.funcReduceWines != nil {
		mmReduceWines.mock.t.Fatalf("IWineRepositoryMock.ReduceWines mock is already set by Set")
	}

	if mmReduceWines.defaultExpectation == nil {
		mmReduceWines.defaultExpectation = &IWineRepositoryMockReduceWinesExpectation{mock: mmReduceWines.mock}
	}
	mmReduceWines.defaultExpectation.results = &IWineRepositoryMockReduceWinesResults{err}
	return mmReduceWines.mock
}

// Set uses given function f to mock the IWineRepository.ReduceWines method
func (mmReduceWines *mIWineRepositoryMockReduceWines) Set(f func(ctx context.Context, id []*models.OrderElement) (err error)) *IWineRepositoryMock {
	if mmReduceWines.defaultExpectation != nil {
		mmReduceWines.mock.t.Fatalf("Default expectation is already set for the IWineRepository.ReduceWines method")
	}

	if len(mmReduceWines.expectations) > 0 {
		mmReduceWines.mock.t.Fatalf("Some expectations are already set for the IWineRepository.ReduceWines method")
	}

	mmReduceWines.mock.funcReduceWines = f
	return mmReduceWines.mock
}

// When sets expectation for the IWineRepository.ReduceWines which will trigger the result defined by the following
// Then helper
func (mmReduceWines *mIWineRepositoryMockReduceWines) When(ctx context.Context, id []*models.OrderElement) *IWineRepositoryMockReduceWinesExpectation {
	if mmReduceWines.mock.funcReduceWines != nil {
		mmReduceWines.mock.t.Fatalf("IWineRepositoryMock.ReduceWines mock is already set by Set")
	}

	expectation := &IWineRepositoryMockReduceWinesExpectation{
		mock:   mmReduceWines.mock,
		params: &IWineRepositoryMockReduceWinesParams{ctx, id},
	}
	mmReduceWines.expectations = append(mmReduceWines.expectations, expectation)
	return expectation
}

// Then sets up IWineRepository.ReduceWines return parameters for the expectation previously defined by the When method
func (e *IWineRepositoryMockReduceWinesExpectation) Then(err error) *IWineRepositoryMock {
	e.results = &IWineRepositoryMockReduceWinesResults{err}
	return e.mock
}

// ReduceWines implements interfaces.IWineRepository
func (mmReduceWines *IWineRepositoryMock) ReduceWines(ctx context.Context, id []*models.OrderElement) (err error) {
	mm_atomic.AddUint64(&mmReduceWines.beforeReduceWinesCounter, 1)
	defer mm_atomic.AddUint64(&mmReduceWines.afterReduceWinesCounter, 1)

	if mmReduceWines.inspectFuncReduceWines != nil {
		mmReduceWines.inspectFuncReduceWines(ctx, id)
	}

	mm_params := &IWineRepositoryMockReduceWinesParams{ctx, id}

	// Record call args
	mmReduceWines.ReduceWinesMock.mutex.Lock()
	mmReduceWines.ReduceWinesMock.callArgs = append(mmReduceWines.ReduceWinesMock.callArgs, mm_params)
	mmReduceWines.ReduceWinesMock.mutex.Unlock()

	for _, e := range mmReduceWines.ReduceWinesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReduceWines.ReduceWinesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReduceWines.ReduceWinesMock.defaultExpectation.Counter, 1)
		mm_want := mmReduceWines.ReduceWinesMock.defaultExpectation.params
		mm_got := IWineRepositoryMockReduceWinesParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReduceWines.t.Errorf("IWineRepositoryMock.ReduceWines got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReduceWines.ReduceWinesMock.defaultExpectation.results
		if mm_results == nil {
			mmReduceWines.t.Fatal("No results are set for the IWineRepositoryMock.ReduceWines")
		}
		return (*mm_results).err
	}
	if mmReduceWines.funcReduceWines != nil {
		return mmReduceWines.funcReduceWines(ctx, id)
	}
	mmReduceWines.t.Fatalf("Unexpected call to IWineRepositoryMock.ReduceWines. %v %v", ctx, id)
	return
}

// ReduceWinesAfterCounter returns a count of finished IWineRepositoryMock.ReduceWines invocations
func (mmReduceWines *IWineRepositoryMock) ReduceWinesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReduceWines.afterReduceWinesCounter)
}

// ReduceWinesBeforeCounter returns a count of IWineRepositoryMock.ReduceWines invocations
func (mmReduceWines *IWineRepositoryMock) ReduceWinesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReduceWines.beforeReduceWinesCounter)
}

// Calls returns a list of arguments used in each call to IWineRepositoryMock.ReduceWines.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReduceWines *mIWineRepositoryMockReduceWines) Calls() []*IWineRepositoryMockReduceWinesParams {
	mmReduceWines.mutex.RLock()

	argCopy := make([]*IWineRepositoryMockReduceWinesParams, len(mmReduceWines.callArgs))
	copy(argCopy, mmReduceWines.callArgs)

	mmReduceWines.mutex.RUnlock()

	return argCopy
}

// MinimockReduceWinesDone returns true if the count of the ReduceWines invocations corresponds
// the number of defined expectations
func (m *IWineRepositoryMock) MinimockReduceWinesDone() bool {
	for _, e := range m.ReduceWinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReduceWinesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReduceWinesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReduceWines != nil && mm_atomic.LoadUint64(&m.afterReduceWinesCounter) < 1 {
		return false
	}
	return true
}

// MinimockReduceWinesInspect logs each unmet expectation
func (m *IWineRepositoryMock) MinimockReduceWinesInspect() {
	for _, e := range m.ReduceWinesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IWineRepositoryMock.ReduceWines with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReduceWinesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReduceWinesCounter) < 1 {
		if m.ReduceWinesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IWineRepositoryMock.ReduceWines")
		} else {
			m.t.Errorf("Expected call to IWineRepositoryMock.ReduceWines with params: %#v", *m.ReduceWinesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReduceWines != nil && mm_atomic.LoadUint64(&m.afterReduceWinesCounter) < 1 {
		m.t.Error("Expected call to IWineRepositoryMock.ReduceWines")
	}
}

type mIWineRepositoryMockUpdate struct {
	mock               *IWineRepositoryMock
	defaultExpectation *IWineRepositoryMockUpdateExpectation
	expectations       []*IWineRepositoryMockUpdateExpectation

	callArgs []*IWineRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// IWineRepositoryMockUpdateExpectation specifies expectation struct of the IWineRepository.Update
type IWineRepositoryMockUpdateExpectation struct {
	mock    *IWineRepositoryMock
	params  *IWineRepositoryMockUpdateParams
	results *IWineRepositoryMockUpdateResults
	Counter uint64
}

// IWineRepositoryMockUpdateParams contains parameters of the IWineRepository.Update
type IWineRepositoryMockUpdateParams struct {
	ctx  context.Context
	wine *models.Wine
}

// IWineRepositoryMockUpdateResults contains results of the IWineRepository.Update
type IWineRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for IWineRepository.Update
func (mmUpdate *mIWineRepositoryMockUpdate) Expect(ctx context.Context, wine *models.Wine) *mIWineRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IWineRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IWineRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &IWineRepositoryMockUpdateParams{ctx, wine}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the IWineRepository.Update
func (mmUpdate *mIWineRepositoryMockUpdate) Inspect(f func(ctx context.Context, wine *models.Wine)) *mIWineRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for IWineRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by IWineRepository.Update
func (mmUpdate *mIWineRepositoryMockUpdate) Return(err error) *IWineRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IWineRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &IWineRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &IWineRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the IWineRepository.Update method
func (mmUpdate *mIWineRepositoryMockUpdate) Set(f func(ctx context.Context, wine *models.Wine) (err error)) *IWineRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the IWineRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the IWineRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the IWineRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mIWineRepositoryMockUpdate) When(ctx context.Context, wine *models.Wine) *IWineRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("IWineRepositoryMock.Update mock is already set by Set")
	}

	expectation := &IWineRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &IWineRepositoryMockUpdateParams{ctx, wine},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up IWineRepository.Update return parameters for the expectation previously defined by the When method
func (e *IWineRepositoryMockUpdateExpectation) Then(err error) *IWineRepositoryMock {
	e.results = &IWineRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements interfaces.IWineRepository
func (mmUpdate *IWineRepositoryMock) Update(ctx context.Context, wine *models.Wine) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, wine)
	}

	mm_params := &IWineRepositoryMockUpdateParams{ctx, wine}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := IWineRepositoryMockUpdateParams{ctx, wine}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("IWineRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the IWineRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, wine)
	}
	mmUpdate.t.Fatalf("Unexpected call to IWineRepositoryMock.Update. %v %v", ctx, wine)
	return
}

// UpdateAfterCounter returns a count of finished IWineRepositoryMock.Update invocations
func (mmUpdate *IWineRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of IWineRepositoryMock.Update invocations
func (mmUpdate *IWineRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to IWineRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mIWineRepositoryMockUpdate) Calls() []*IWineRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*IWineRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *IWineRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *IWineRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IWineRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IWineRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to IWineRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to IWineRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IWineRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteInspect()

		m.MinimockGetWineInspect()

		m.MinimockGetWinesInspect()

		m.MinimockInsertInspect()

		m.MinimockReduceWinesInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IWineRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IWineRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockGetWineDone() &&
		m.MinimockGetWinesDone() &&
		m.MinimockInsertDone() &&
		m.MinimockReduceWinesDone() &&
		m.MinimockUpdateDone()
}
