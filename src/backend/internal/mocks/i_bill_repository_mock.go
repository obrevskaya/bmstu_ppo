package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i git.iu7.bmstu.ru/ovv20u676/ppo/src/internal/interfaces.IBillRepository -o ../mocks/i_bill_repository_mock_test.go -n IBillRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"git.iu7.bmstu.ru/ovv20u676/ppo/src/backend/internal/logic/models"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// IBillRepositoryMock implements interfaces.IBillRepository
type IBillRepositoryMock struct {
	t minimock.Tester

	funcGet          func(ctx context.Context, ID uuid.UUID) (bp1 *models.Bill, err error)
	inspectFuncGet   func(ctx context.Context, ID uuid.UUID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mIBillRepositoryMockGet

	funcInsert          func(ctx context.Context, bill *models.Bill) (err error)
	inspectFuncInsert   func(ctx context.Context, bill *models.Bill)
	afterInsertCounter  uint64
	beforeInsertCounter uint64
	InsertMock          mIBillRepositoryMockInsert

	funcUpdateBillStatus          func(ctx context.Context, ID uuid.UUID, status string, points int) (err error)
	inspectFuncUpdateBillStatus   func(ctx context.Context, ID uuid.UUID, status string, points int)
	afterUpdateBillStatusCounter  uint64
	beforeUpdateBillStatusCounter uint64
	UpdateBillStatusMock          mIBillRepositoryMockUpdateBillStatus
}

// NewIBillRepositoryMock returns a mock for interfaces.IBillRepository
func NewIBillRepositoryMock(t minimock.Tester) *IBillRepositoryMock {
	m := &IBillRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetMock = mIBillRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*IBillRepositoryMockGetParams{}

	m.InsertMock = mIBillRepositoryMockInsert{mock: m}
	m.InsertMock.callArgs = []*IBillRepositoryMockInsertParams{}

	m.UpdateBillStatusMock = mIBillRepositoryMockUpdateBillStatus{mock: m}
	m.UpdateBillStatusMock.callArgs = []*IBillRepositoryMockUpdateBillStatusParams{}

	return m
}

type mIBillRepositoryMockGet struct {
	mock               *IBillRepositoryMock
	defaultExpectation *IBillRepositoryMockGetExpectation
	expectations       []*IBillRepositoryMockGetExpectation

	callArgs []*IBillRepositoryMockGetParams
	mutex    sync.RWMutex
}

// IBillRepositoryMockGetExpectation specifies expectation struct of the IBillRepository.Get
type IBillRepositoryMockGetExpectation struct {
	mock    *IBillRepositoryMock
	params  *IBillRepositoryMockGetParams
	results *IBillRepositoryMockGetResults
	Counter uint64
}

// IBillRepositoryMockGetParams contains parameters of the IBillRepository.Get
type IBillRepositoryMockGetParams struct {
	ctx context.Context
	ID  uuid.UUID
}

// IBillRepositoryMockGetResults contains results of the IBillRepository.Get
type IBillRepositoryMockGetResults struct {
	bp1 *models.Bill
	err error
}

// Expect sets up expected params for IBillRepository.Get
func (mmGet *mIBillRepositoryMockGet) Expect(ctx context.Context, ID uuid.UUID) *mIBillRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IBillRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &IBillRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &IBillRepositoryMockGetParams{ctx, ID}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the IBillRepository.Get
func (mmGet *mIBillRepositoryMockGet) Inspect(f func(ctx context.Context, ID uuid.UUID)) *mIBillRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for IBillRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by IBillRepository.Get
func (mmGet *mIBillRepositoryMockGet) Return(bp1 *models.Bill, err error) *IBillRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IBillRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &IBillRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &IBillRepositoryMockGetResults{bp1, err}
	return mmGet.mock
}

// Set uses given function f to mock the IBillRepository.Get method
func (mmGet *mIBillRepositoryMockGet) Set(f func(ctx context.Context, ID uuid.UUID) (bp1 *models.Bill, err error)) *IBillRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the IBillRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the IBillRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the IBillRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mIBillRepositoryMockGet) When(ctx context.Context, ID uuid.UUID) *IBillRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("IBillRepositoryMock.Get mock is already set by Set")
	}

	expectation := &IBillRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &IBillRepositoryMockGetParams{ctx, ID},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up IBillRepository.Get return parameters for the expectation previously defined by the When method
func (e *IBillRepositoryMockGetExpectation) Then(bp1 *models.Bill, err error) *IBillRepositoryMock {
	e.results = &IBillRepositoryMockGetResults{bp1, err}
	return e.mock
}

// Get implements interfaces.IBillRepository
func (mmGet *IBillRepositoryMock) Get(ctx context.Context, ID uuid.UUID) (bp1 *models.Bill, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, ID)
	}

	mm_params := &IBillRepositoryMockGetParams{ctx, ID}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := IBillRepositoryMockGetParams{ctx, ID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("IBillRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the IBillRepositoryMock.Get")
		}
		return (*mm_results).bp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, ID)
	}
	mmGet.t.Fatalf("Unexpected call to IBillRepositoryMock.Get. %v %v", ctx, ID)
	return
}

// GetAfterCounter returns a count of finished IBillRepositoryMock.Get invocations
func (mmGet *IBillRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of IBillRepositoryMock.Get invocations
func (mmGet *IBillRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to IBillRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mIBillRepositoryMockGet) Calls() []*IBillRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*IBillRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *IBillRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *IBillRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IBillRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IBillRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to IBillRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to IBillRepositoryMock.Get")
	}
}

type mIBillRepositoryMockInsert struct {
	mock               *IBillRepositoryMock
	defaultExpectation *IBillRepositoryMockInsertExpectation
	expectations       []*IBillRepositoryMockInsertExpectation

	callArgs []*IBillRepositoryMockInsertParams
	mutex    sync.RWMutex
}

// IBillRepositoryMockInsertExpectation specifies expectation struct of the IBillRepository.Insert
type IBillRepositoryMockInsertExpectation struct {
	mock    *IBillRepositoryMock
	params  *IBillRepositoryMockInsertParams
	results *IBillRepositoryMockInsertResults
	Counter uint64
}

// IBillRepositoryMockInsertParams contains parameters of the IBillRepository.Insert
type IBillRepositoryMockInsertParams struct {
	ctx  context.Context
	bill *models.Bill
}

// IBillRepositoryMockInsertResults contains results of the IBillRepository.Insert
type IBillRepositoryMockInsertResults struct {
	err error
}

// Expect sets up expected params for IBillRepository.Insert
func (mmInsert *mIBillRepositoryMockInsert) Expect(ctx context.Context, bill *models.Bill) *mIBillRepositoryMockInsert {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("IBillRepositoryMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &IBillRepositoryMockInsertExpectation{}
	}

	mmInsert.defaultExpectation.params = &IBillRepositoryMockInsertParams{ctx, bill}
	for _, e := range mmInsert.expectations {
		if minimock.Equal(e.params, mmInsert.defaultExpectation.params) {
			mmInsert.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsert.defaultExpectation.params)
		}
	}

	return mmInsert
}

// Inspect accepts an inspector function that has same arguments as the IBillRepository.Insert
func (mmInsert *mIBillRepositoryMockInsert) Inspect(f func(ctx context.Context, bill *models.Bill)) *mIBillRepositoryMockInsert {
	if mmInsert.mock.inspectFuncInsert != nil {
		mmInsert.mock.t.Fatalf("Inspect function is already set for IBillRepositoryMock.Insert")
	}

	mmInsert.mock.inspectFuncInsert = f

	return mmInsert
}

// Return sets up results that will be returned by IBillRepository.Insert
func (mmInsert *mIBillRepositoryMockInsert) Return(err error) *IBillRepositoryMock {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("IBillRepositoryMock.Insert mock is already set by Set")
	}

	if mmInsert.defaultExpectation == nil {
		mmInsert.defaultExpectation = &IBillRepositoryMockInsertExpectation{mock: mmInsert.mock}
	}
	mmInsert.defaultExpectation.results = &IBillRepositoryMockInsertResults{err}
	return mmInsert.mock
}

// Set uses given function f to mock the IBillRepository.Insert method
func (mmInsert *mIBillRepositoryMockInsert) Set(f func(ctx context.Context, bill *models.Bill) (err error)) *IBillRepositoryMock {
	if mmInsert.defaultExpectation != nil {
		mmInsert.mock.t.Fatalf("Default expectation is already set for the IBillRepository.Insert method")
	}

	if len(mmInsert.expectations) > 0 {
		mmInsert.mock.t.Fatalf("Some expectations are already set for the IBillRepository.Insert method")
	}

	mmInsert.mock.funcInsert = f
	return mmInsert.mock
}

// When sets expectation for the IBillRepository.Insert which will trigger the result defined by the following
// Then helper
func (mmInsert *mIBillRepositoryMockInsert) When(ctx context.Context, bill *models.Bill) *IBillRepositoryMockInsertExpectation {
	if mmInsert.mock.funcInsert != nil {
		mmInsert.mock.t.Fatalf("IBillRepositoryMock.Insert mock is already set by Set")
	}

	expectation := &IBillRepositoryMockInsertExpectation{
		mock:   mmInsert.mock,
		params: &IBillRepositoryMockInsertParams{ctx, bill},
	}
	mmInsert.expectations = append(mmInsert.expectations, expectation)
	return expectation
}

// Then sets up IBillRepository.Insert return parameters for the expectation previously defined by the When method
func (e *IBillRepositoryMockInsertExpectation) Then(err error) *IBillRepositoryMock {
	e.results = &IBillRepositoryMockInsertResults{err}
	return e.mock
}

// Insert implements interfaces.IBillRepository
func (mmInsert *IBillRepositoryMock) Insert(ctx context.Context, bill *models.Bill) (err error) {
	mm_atomic.AddUint64(&mmInsert.beforeInsertCounter, 1)
	defer mm_atomic.AddUint64(&mmInsert.afterInsertCounter, 1)

	if mmInsert.inspectFuncInsert != nil {
		mmInsert.inspectFuncInsert(ctx, bill)
	}

	mm_params := &IBillRepositoryMockInsertParams{ctx, bill}

	// Record call args
	mmInsert.InsertMock.mutex.Lock()
	mmInsert.InsertMock.callArgs = append(mmInsert.InsertMock.callArgs, mm_params)
	mmInsert.InsertMock.mutex.Unlock()

	for _, e := range mmInsert.InsertMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsert.InsertMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsert.InsertMock.defaultExpectation.Counter, 1)
		mm_want := mmInsert.InsertMock.defaultExpectation.params
		mm_got := IBillRepositoryMockInsertParams{ctx, bill}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsert.t.Errorf("IBillRepositoryMock.Insert got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsert.InsertMock.defaultExpectation.results
		if mm_results == nil {
			mmInsert.t.Fatal("No results are set for the IBillRepositoryMock.Insert")
		}
		return (*mm_results).err
	}
	if mmInsert.funcInsert != nil {
		return mmInsert.funcInsert(ctx, bill)
	}
	mmInsert.t.Fatalf("Unexpected call to IBillRepositoryMock.Insert. %v %v", ctx, bill)
	return
}

// InsertAfterCounter returns a count of finished IBillRepositoryMock.Insert invocations
func (mmInsert *IBillRepositoryMock) InsertAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.afterInsertCounter)
}

// InsertBeforeCounter returns a count of IBillRepositoryMock.Insert invocations
func (mmInsert *IBillRepositoryMock) InsertBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsert.beforeInsertCounter)
}

// Calls returns a list of arguments used in each call to IBillRepositoryMock.Insert.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsert *mIBillRepositoryMockInsert) Calls() []*IBillRepositoryMockInsertParams {
	mmInsert.mutex.RLock()

	argCopy := make([]*IBillRepositoryMockInsertParams, len(mmInsert.callArgs))
	copy(argCopy, mmInsert.callArgs)

	mmInsert.mutex.RUnlock()

	return argCopy
}

// MinimockInsertDone returns true if the count of the Insert invocations corresponds
// the number of defined expectations
func (m *IBillRepositoryMock) MinimockInsertDone() bool {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertInspect logs each unmet expectation
func (m *IBillRepositoryMock) MinimockInsertInspect() {
	for _, e := range m.InsertMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IBillRepositoryMock.Insert with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		if m.InsertMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IBillRepositoryMock.Insert")
		} else {
			m.t.Errorf("Expected call to IBillRepositoryMock.Insert with params: %#v", *m.InsertMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsert != nil && mm_atomic.LoadUint64(&m.afterInsertCounter) < 1 {
		m.t.Error("Expected call to IBillRepositoryMock.Insert")
	}
}

type mIBillRepositoryMockUpdateBillStatus struct {
	mock               *IBillRepositoryMock
	defaultExpectation *IBillRepositoryMockUpdateBillStatusExpectation
	expectations       []*IBillRepositoryMockUpdateBillStatusExpectation

	callArgs []*IBillRepositoryMockUpdateBillStatusParams
	mutex    sync.RWMutex
}

// IBillRepositoryMockUpdateBillStatusExpectation specifies expectation struct of the IBillRepository.UpdateBillStatus
type IBillRepositoryMockUpdateBillStatusExpectation struct {
	mock    *IBillRepositoryMock
	params  *IBillRepositoryMockUpdateBillStatusParams
	results *IBillRepositoryMockUpdateBillStatusResults
	Counter uint64
}

// IBillRepositoryMockUpdateBillStatusParams contains parameters of the IBillRepository.UpdateBillStatus
type IBillRepositoryMockUpdateBillStatusParams struct {
	ctx    context.Context
	ID     uuid.UUID
	status string
	points int
}

// IBillRepositoryMockUpdateBillStatusResults contains results of the IBillRepository.UpdateBillStatus
type IBillRepositoryMockUpdateBillStatusResults struct {
	err error
}

// Expect sets up expected params for IBillRepository.UpdateBillStatus
func (mmUpdateBillStatus *mIBillRepositoryMockUpdateBillStatus) Expect(ctx context.Context, ID uuid.UUID, status string, points int) *mIBillRepositoryMockUpdateBillStatus {
	if mmUpdateBillStatus.mock.funcUpdateBillStatus != nil {
		mmUpdateBillStatus.mock.t.Fatalf("IBillRepositoryMock.UpdateBillStatus mock is already set by Set")
	}

	if mmUpdateBillStatus.defaultExpectation == nil {
		mmUpdateBillStatus.defaultExpectation = &IBillRepositoryMockUpdateBillStatusExpectation{}
	}

	mmUpdateBillStatus.defaultExpectation.params = &IBillRepositoryMockUpdateBillStatusParams{ctx, ID, status, points}
	for _, e := range mmUpdateBillStatus.expectations {
		if minimock.Equal(e.params, mmUpdateBillStatus.defaultExpectation.params) {
			mmUpdateBillStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateBillStatus.defaultExpectation.params)
		}
	}

	return mmUpdateBillStatus
}

// Inspect accepts an inspector function that has same arguments as the IBillRepository.UpdateBillStatus
func (mmUpdateBillStatus *mIBillRepositoryMockUpdateBillStatus) Inspect(f func(ctx context.Context, ID uuid.UUID, status string, points int)) *mIBillRepositoryMockUpdateBillStatus {
	if mmUpdateBillStatus.mock.inspectFuncUpdateBillStatus != nil {
		mmUpdateBillStatus.mock.t.Fatalf("Inspect function is already set for IBillRepositoryMock.UpdateBillStatus")
	}

	mmUpdateBillStatus.mock.inspectFuncUpdateBillStatus = f

	return mmUpdateBillStatus
}

// Return sets up results that will be returned by IBillRepository.UpdateBillStatus
func (mmUpdateBillStatus *mIBillRepositoryMockUpdateBillStatus) Return(err error) *IBillRepositoryMock {
	if mmUpdateBillStatus.mock.funcUpdateBillStatus != nil {
		mmUpdateBillStatus.mock.t.Fatalf("IBillRepositoryMock.UpdateBillStatus mock is already set by Set")
	}

	if mmUpdateBillStatus.defaultExpectation == nil {
		mmUpdateBillStatus.defaultExpectation = &IBillRepositoryMockUpdateBillStatusExpectation{mock: mmUpdateBillStatus.mock}
	}
	mmUpdateBillStatus.defaultExpectation.results = &IBillRepositoryMockUpdateBillStatusResults{err}
	return mmUpdateBillStatus.mock
}

// Set uses given function f to mock the IBillRepository.UpdateBillStatus method
func (mmUpdateBillStatus *mIBillRepositoryMockUpdateBillStatus) Set(f func(ctx context.Context, ID uuid.UUID, status string, points int) (err error)) *IBillRepositoryMock {
	if mmUpdateBillStatus.defaultExpectation != nil {
		mmUpdateBillStatus.mock.t.Fatalf("Default expectation is already set for the IBillRepository.UpdateBillStatus method")
	}

	if len(mmUpdateBillStatus.expectations) > 0 {
		mmUpdateBillStatus.mock.t.Fatalf("Some expectations are already set for the IBillRepository.UpdateBillStatus method")
	}

	mmUpdateBillStatus.mock.funcUpdateBillStatus = f
	return mmUpdateBillStatus.mock
}

// When sets expectation for the IBillRepository.UpdateBillStatus which will trigger the result defined by the following
// Then helper
func (mmUpdateBillStatus *mIBillRepositoryMockUpdateBillStatus) When(ctx context.Context, ID uuid.UUID, status string, points int) *IBillRepositoryMockUpdateBillStatusExpectation {
	if mmUpdateBillStatus.mock.funcUpdateBillStatus != nil {
		mmUpdateBillStatus.mock.t.Fatalf("IBillRepositoryMock.UpdateBillStatus mock is already set by Set")
	}

	expectation := &IBillRepositoryMockUpdateBillStatusExpectation{
		mock:   mmUpdateBillStatus.mock,
		params: &IBillRepositoryMockUpdateBillStatusParams{ctx, ID, status, points},
	}
	mmUpdateBillStatus.expectations = append(mmUpdateBillStatus.expectations, expectation)
	return expectation
}

// Then sets up IBillRepository.UpdateBillStatus return parameters for the expectation previously defined by the When method
func (e *IBillRepositoryMockUpdateBillStatusExpectation) Then(err error) *IBillRepositoryMock {
	e.results = &IBillRepositoryMockUpdateBillStatusResults{err}
	return e.mock
}

// UpdateBillStatus implements interfaces.IBillRepository
func (mmUpdateBillStatus *IBillRepositoryMock) UpdateBillStatus(ctx context.Context, ID uuid.UUID, status string, points int) (err error) {
	mm_atomic.AddUint64(&mmUpdateBillStatus.beforeUpdateBillStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateBillStatus.afterUpdateBillStatusCounter, 1)

	if mmUpdateBillStatus.inspectFuncUpdateBillStatus != nil {
		mmUpdateBillStatus.inspectFuncUpdateBillStatus(ctx, ID, status, points)
	}

	mm_params := &IBillRepositoryMockUpdateBillStatusParams{ctx, ID, status, points}

	// Record call args
	mmUpdateBillStatus.UpdateBillStatusMock.mutex.Lock()
	mmUpdateBillStatus.UpdateBillStatusMock.callArgs = append(mmUpdateBillStatus.UpdateBillStatusMock.callArgs, mm_params)
	mmUpdateBillStatus.UpdateBillStatusMock.mutex.Unlock()

	for _, e := range mmUpdateBillStatus.UpdateBillStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateBillStatus.UpdateBillStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateBillStatus.UpdateBillStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateBillStatus.UpdateBillStatusMock.defaultExpectation.params
		mm_got := IBillRepositoryMockUpdateBillStatusParams{ctx, ID, status, points}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateBillStatus.t.Errorf("IBillRepositoryMock.UpdateBillStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateBillStatus.UpdateBillStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateBillStatus.t.Fatal("No results are set for the IBillRepositoryMock.UpdateBillStatus")
		}
		return (*mm_results).err
	}
	if mmUpdateBillStatus.funcUpdateBillStatus != nil {
		return mmUpdateBillStatus.funcUpdateBillStatus(ctx, ID, status, points)
	}
	mmUpdateBillStatus.t.Fatalf("Unexpected call to IBillRepositoryMock.UpdateBillStatus. %v %v %v %v", ctx, ID, status, points)
	return
}

// UpdateBillStatusAfterCounter returns a count of finished IBillRepositoryMock.UpdateBillStatus invocations
func (mmUpdateBillStatus *IBillRepositoryMock) UpdateBillStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBillStatus.afterUpdateBillStatusCounter)
}

// UpdateBillStatusBeforeCounter returns a count of IBillRepositoryMock.UpdateBillStatus invocations
func (mmUpdateBillStatus *IBillRepositoryMock) UpdateBillStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateBillStatus.beforeUpdateBillStatusCounter)
}

// Calls returns a list of arguments used in each call to IBillRepositoryMock.UpdateBillStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateBillStatus *mIBillRepositoryMockUpdateBillStatus) Calls() []*IBillRepositoryMockUpdateBillStatusParams {
	mmUpdateBillStatus.mutex.RLock()

	argCopy := make([]*IBillRepositoryMockUpdateBillStatusParams, len(mmUpdateBillStatus.callArgs))
	copy(argCopy, mmUpdateBillStatus.callArgs)

	mmUpdateBillStatus.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateBillStatusDone returns true if the count of the UpdateBillStatus invocations corresponds
// the number of defined expectations
func (m *IBillRepositoryMock) MinimockUpdateBillStatusDone() bool {
	for _, e := range m.UpdateBillStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateBillStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateBillStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateBillStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateBillStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateBillStatusInspect logs each unmet expectation
func (m *IBillRepositoryMock) MinimockUpdateBillStatusInspect() {
	for _, e := range m.UpdateBillStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IBillRepositoryMock.UpdateBillStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateBillStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateBillStatusCounter) < 1 {
		if m.UpdateBillStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IBillRepositoryMock.UpdateBillStatus")
		} else {
			m.t.Errorf("Expected call to IBillRepositoryMock.UpdateBillStatus with params: %#v", *m.UpdateBillStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateBillStatus != nil && mm_atomic.LoadUint64(&m.afterUpdateBillStatusCounter) < 1 {
		m.t.Error("Expected call to IBillRepositoryMock.UpdateBillStatus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IBillRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetInspect()

		m.MinimockInsertInspect()

		m.MinimockUpdateBillStatusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IBillRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IBillRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDone() &&
		m.MinimockInsertDone() &&
		m.MinimockUpdateBillStatusDone()
}
